import { expect } from 'chai';
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

suite('Extension Workspace Integration Tests', () => {
    let tempWorkspace: string;
    
    suiteSetup(async () => {
        tempWorkspace = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'workspace-integration-test-'));
        
        // Create a test workspace structure
        await fs.promises.mkdir(path.join(tempWorkspace, 'src'), { recursive: true });
        await fs.promises.mkdir(path.join(tempWorkspace, 'src', 'components'), { recursive: true });
        await fs.promises.mkdir(path.join(tempWorkspace, 'docs'), { recursive: true });
        
        // Create some test files
        await fs.promises.writeFile(path.join(tempWorkspace, 'src', 'main.ts'), 'console.log("test");');
        await fs.promises.writeFile(path.join(tempWorkspace, 'src', 'components', 'button.tsx'), '<Button />');
        await fs.promises.writeFile(path.join(tempWorkspace, 'docs', 'readme.md'), '# Test');
    });
    
    suiteTeardown(async () => {
        await fs.promises.rm(tempWorkspace, { recursive: true, force: true });
    });

    test('should detect workspace when VS Code workspace is available', async () => {
        // This test would require mocking VS Code workspace
        // For now, we'll test the basic logic
        const hasWorkspace = vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0;
        
        if (hasWorkspace) {
            expect(vscode.workspace.workspaceFolders).to.not.be.undefined;
            expect(vscode.workspace.workspaceFolders!.length).to.be.greaterThan(0);
        }
    });

    test('should handle workspace settings creation command', async () => {
        // Test the command registration and basic functionality
        const commands = await vscode.commands.getCommands();
        expect(commands).to.include('codeCounter.openSettings');
    });

    test('should create workspace settings file structure', async () => {
        const settingsPath = path.join(tempWorkspace, '.code-counter.json');
        
        // Simulate creating workspace settings
        const testSettings = {
            lineThresholds: {
                warning: 75,
                danger: 150
            },
            emojis: {
                normal: '🔵',
                warning: '🟡',
                danger: '🔴'
            }
        };
        
        await fs.promises.writeFile(settingsPath, JSON.stringify(testSettings, null, 2));
        
        // Verify file was created correctly
        const exists = await fs.promises.access(settingsPath).then(() => true).catch(() => false);
        expect(exists).to.be.true;
        
        const content = await fs.promises.readFile(settingsPath, 'utf-8');
        const parsed = JSON.parse(content);
        expect(parsed.lineThresholds.warning).to.equal(75);
        expect(parsed.emojis.normal).to.equal('🔵');
    });

    test('should handle nested workspace settings inheritance', async () => {
        // Create nested settings
        const srcSettingsPath = path.join(tempWorkspace, 'src', '.code-counter.json');
        const srcSettings = {
            lineThresholds: {
                warning: 50 // Override warning threshold for src
            },
            emojis: {
                normal: '⚙️' // Override normal emoji for src
            }
        };
        
        await fs.promises.writeFile(srcSettingsPath, JSON.stringify(srcSettings, null, 2));
        
        // Create component-specific settings
        const componentsSettingsPath = path.join(tempWorkspace, 'src', 'components', '.code-counter.json');
        const componentsSettings = {
            emojis: {
                danger: '⚠️' // Override danger emoji for components
            }
        };
        
        await fs.promises.writeFile(componentsSettingsPath, JSON.stringify(componentsSettings, null, 2));
        
        // Verify files exist
        const srcExists = await fs.promises.access(srcSettingsPath).then(() => true).catch(() => false);
        const componentsExists = await fs.promises.access(componentsSettingsPath).then(() => true).catch(() => false);
        
        expect(srcExists).to.be.true;
        expect(componentsExists).to.be.true;
    });

    test('should handle settings file deletion', async () => {
        const testPath = path.join(tempWorkspace, 'test-delete', '.code-counter.json');
        await fs.promises.mkdir(path.dirname(testPath), { recursive: true });
        await fs.promises.writeFile(testPath, '{}');
        
        // Verify file exists
        let exists = await fs.promises.access(testPath).then(() => true).catch(() => false);
        expect(exists).to.be.true;
        
        // Delete file
        await fs.promises.unlink(testPath);
        
        // Verify file is deleted
        exists = await fs.promises.access(testPath).then(() => true).catch(() => false);
        expect(exists).to.be.false;
    });

    test('should validate JSON structure', async () => {
        const validSettings = {
            lineThresholds: {
                warning: 100,
                danger: 200
            },
            emojis: {
                normal: '🟢',
                warning: '🟡',
                danger: '🔴'
            }
        };
        
        // Test valid JSON
        const validJson = JSON.stringify(validSettings, null, 2);
        expect(() => JSON.parse(validJson)).to.not.throw();
        
        const parsed = JSON.parse(validJson);
        expect(parsed).to.deep.equal(validSettings);
    });

    test('should handle malformed JSON gracefully', async () => {
        const malformedPath = path.join(tempWorkspace, 'malformed', '.code-counter.json');
        await fs.promises.mkdir(path.dirname(malformedPath), { recursive: true });
        await fs.promises.writeFile(malformedPath, '{ "lineThresholds": { "warning": 100, } }'); // Invalid trailing comma
        
        // Should handle parsing error gracefully
        let parseError = false;
        try {
            const content = await fs.promises.readFile(malformedPath, 'utf-8');
            JSON.parse(content);
        } catch (error) {
            parseError = true;
        }
        
        expect(parseError).to.be.true;
    });

    test('should handle directory scanning', async () => {
        // Test that we can scan directories and find settings files
        const findSettingsFiles = async (dir: string): Promise<string[]> => {
            const found: string[] = [];
            const scan = async (currentDir: string) => {
                try {
                    const entries = await fs.promises.readdir(currentDir, { withFileTypes: true });
                    for (const entry of entries) {
                        const fullPath = path.join(currentDir, entry.name);
                        if (entry.isDirectory()) {
                            await scan(fullPath);
                        } else if (entry.name === '.code-counter.json') {
                            found.push(fullPath);
                        }
                    }
                } catch (error) {
                    // Ignore permission errors or other issues
                }
            };
            await scan(dir);
            return found;
        };
        
        const settingsFiles = await findSettingsFiles(tempWorkspace);
        expect(settingsFiles.length).to.be.greaterThan(0);
        
        // Verify we found the expected files
        const expectedFiles = [
            path.join(tempWorkspace, '.code-counter.json'),
            path.join(tempWorkspace, 'src', '.code-counter.json'),
            path.join(tempWorkspace, 'src', 'components', '.code-counter.json')
        ];
        
        for (const expectedFile of expectedFiles) {
            const exists = await fs.promises.access(expectedFile).then(() => true).catch(() => false);
            if (exists) {
                expect(settingsFiles).to.include(expectedFile);
            }
        }
    });

    test('should handle empty workspace gracefully', async () => {
        const emptyWorkspace = path.join(tempWorkspace, 'empty');
        await fs.promises.mkdir(emptyWorkspace, { recursive: true });
        
        // Should not throw when scanning empty directory
        const entries = await fs.promises.readdir(emptyWorkspace);
        expect(entries).to.be.an('array');
        expect(entries.length).to.equal(0);
    });

    test('should respect file system permissions', async () => {
        // Skip on Windows due to different permission model
        if (process.platform === 'win32') {
            return;
        }
        
        const restrictedDir = path.join(tempWorkspace, 'restricted');
        await fs.promises.mkdir(restrictedDir, { recursive: true });
        
        // Create a file and make it read-only
        const restrictedFile = path.join(restrictedDir, '.code-counter.json');
        await fs.promises.writeFile(restrictedFile, '{}');
        await fs.promises.chmod(restrictedFile, 0o444);
        
        try {
            // Should not be able to write to read-only file
            let writeError = false;
            try {
                await fs.promises.writeFile(restrictedFile, '{"test": "value"}');
            } catch (error) {
                writeError = true;
            }
            expect(writeError).to.be.true;
        } finally {
            // Restore permissions for cleanup
            await fs.promises.chmod(restrictedFile, 0o644);
        }
    });
});